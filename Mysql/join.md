## Mysql中的left join、right join 、inner join 用法的分析

### 建立两张测试表

#### A表

| aID  |   aNum    |
| :--: | :-------: |
|  1   | a20180410 |
|  2   | a20180411 |
|  3   | a20180412 |
|  4   | a20180413 |
|  5   | a20180414 |

#### B表

| bID  |   bName   |
| :--: | :-------: |
|  1   | b20180410 |
|  2   | b20180411 |
|  3   | b20180412 |
|  4   | b20180413 |
|  8   | b20180414 |

#### 创建表的sql语句如下

##### A表

```mysql
CREATE TABLE a(
    aID int(1) AUTO_INCREMENT PRIMARY KEY,
    aNum char(20)
    );
INSERT INTO a VALUES (1,'a20180410'),(2, 'a20180411'),
	(3, 'a20180412'),(4, 'a20180413'),(5, 'a20180414');
```



##### B表

```mysql
CREATE TABLE b(
    bID int(1) AUTO_INCREMENT PRIMARY KEY,
    bName char(20)
    );
INSERT INTO b VALUES (1,'b20180410'),(2, 'b20180411'),
    (3, 'b20180412'),(4, 'b20180413'),(8, 'b20180414');
```







### join测试

#### 1. left join (左连接)

##### sql语句

```mysql
SELECT * FROM a 
LEFT JOIN  b  
ON a.aID =b.bID 
```

##### 执行结果

```bash
+-----+-----------+------+-----------+
| aID | aNum      | bID  | bName     |
+-----+-----------+------+-----------+
|   1 | a20180410 |    1 | b20180410 |
|   2 | a20180411 |    2 | b20180411 |
|   3 | a20180412 |    3 | b20180412 |
|   4 | a20180413 |    4 | b20180413 |
|   5 | a20180414 | NULL | NULL      |
+-----+-----------+------+-----------+
```

影响了5行的数据

##### 结果分析

> left join是以A表的记录为基础的,A可以看成左表,B可以看成右表,left join是以左表为准的. 
> 换句话说,左表(A)的记录将会全部表示出来,而右表(B)只会显示符合搜索条件的记录(例子中为: A.aID = B.bID). 
> B表记录不足的地方均为NULL. 



#### 2. right join (右连接)

##### sql语句

```mysql
SELECT * FROM a
RIGHT JOIN b
ON a.aID = b.bID;
```

##### 执行结果

```bash
+------+-----------+-----+-----------+
| aID  | aNum      | bID | bName     |
+------+-----------+-----+-----------+
|    1 | a20180410 |   1 | b20180410 |
|    2 | a20180411 |   2 | b20180411 |
|    3 | a20180412 |   3 | b20180412 |
|    4 | a20180413 |   4 | b20180413 |
| NULL | NULL      |   8 | b20180414 |
+------+-----------+-----+-----------+
```

影响了5行数据

##### 结果分析

> 仔细观察一下,就会发现,和left join的结果刚好相反,这次是以右表(B)为基础的,A表不足的地方用NULL填充. 



#### 3.inner join (内连接)

##### sql语句

```mysql
SELECT * FROM  a 
INNER JOIN  b 
ON a.aID =b.bID 
```

##### 执行结果

```bash
+-----+-----------+-----+-----------+
| aID | aNum      | bID | bName     |
+-----+-----------+-----+-----------+
|   1 | a20180410 |   1 | b20180410 |
|   2 | a20180411 |   2 | b20180411 |
|   3 | a20180412 |   3 | b20180412 |
|   4 | a20180413 |   4 | b20180413 |
+-----+-----------+-----+-----------+
```

只查询出了4条数据

##### 结果分析

> 很明显,这里只显示出了 A.aID = B.bID的记录.这说明inner join并不以谁为基础,它只显示符合条件的记录. 



​	

